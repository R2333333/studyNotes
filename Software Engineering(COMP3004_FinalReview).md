# What is Software Engineering? Why is it necessary?
 Activities of: Modeling, Problem Solving, and Knowledge acquisition.
 A realiable process of building softwares.
 
 It is necessary because we need to build a realiable and motifiable system.
 
 Two aspect: Technical aspect and Menagement aspect
 
 # Modeling
 Model is a virtual representation of the part of the real world that we are going to build.
 
 Why Build models:
    To get better idea of how to build the real system and clearify the details of the system.
    (Since the real system could be too big or too complex for us to understand it as a whole stuff)
    
 Traceability:
    The requirment need to be able to be tracked throught the entire developement process.
    (If something in the system need to be changed, we need to know what else relating to this part also need to change)
    
 # Software Development Life Circle
 1. Requirement Elicitation : 
     produces a system requirement(consist of a functional model, and non-functional requirement) 
 
 2. Requirement Analysis: produces
     Functional Requirement;
     Functional Model; 
     Non-Functional Requirement;
     Non-Functional Model;
     
 3. High Level System Design: 
     System Model (Subsystem decomposition, System Architecher Strategies)
 
 4. Detailed Object Design:
 
 5. Implementation:
      Mapping associations to collections in a programming language
 
 6. Testing
 
 7. Dployment and Maintenance
 
 # Models in Requirment Analysis
 1. Functional Model(Use Case, Requirments)
 2. Dynamic Model(Statemachine, Sequence Diagram, Activity Diagram)
 3. Object Model (Class Diagram, Data Dictionary)
 
 # Requirment Elicitation
 1. Need to know what the clients want
 2. Figure out the functional and non-functionl requirment
 3. Make scenarios and use case
 
 Use Case includes:
   
    1. High level use case and detailed use case.
   
    2. Actors, System boundaries.
   
    3. Relations between Actors and use cases.
   
    4. Relations between use cases and use cases.
   
    5. UML Use Case Diagrams, Use Case Table descriptions
   
# Requirement Analysis
  
   1. Dynamic Models: 
    
   2. Object Model:
     The objects can be found in use case
    
# Design Patterns
Creational:
    
   Abstract Factory:
   
    Enable client dependent creation of objects
    Provide Client with interface to classes with different implementation
     
Structrual

   Adapter:
   
    Convert existing component interface to user expected interface
   Bridge:
    
    Allows different impletation for one single interface.
   Composite
   Facade
   Proxy

Behavioural
   Command
   Observer
   Strategy
 
