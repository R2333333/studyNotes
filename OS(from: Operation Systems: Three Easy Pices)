
Cp4.	
-------------------------------------------------------		
Processes(abstract): (virtualizing the cpu, makes illusion for each process that they own the entire CPU)
	Time Sharing:
		Allow processes to share the same resource one while by one while	
	Space Sharing:
		Divide resouce in to parts for sharing purpose
		
	DataStructures:
	
Cp5.
-------------------------------------------------------
ProcessAPI:
	System Calls:
    	<unistd.h>:
        	int execl(const char* path, const char* arg, const char* arg,.......)
        	int execv(const char *path, char *const argv[])
        	int execle(const char *path, const char *arg,..., char * const envp[])
        	int execvpe(const char *file, char *const argv[],char *const envp[])
        	fork()
        	wait()

    	<fcntl.h>:
        	open(const char* path, int Oflag, ...)
	
	CREATE: turn programs into processes, by loading codes into memory and address, 
		allocate memory for stack and heap, initializations like setting up file discriptors for std I/O.
		
		Lazily: load only when needed
			Paging, Swapping.
			
		Eagerly: load all before running
		
	
	DESTROY, WAIT, MISCELLANCE CONTROL 
	
	STATUS: Running, Ready, Blocked, Initial, Final(Zombie state: process finished but not cleaned up)
	
	
	Schedualer
	
Cp6.
-------------------------------------------------------
Limited Direct Execution: Makes processes run efficiently and safely
	Direct Execution:
		Runs processes directly. Processes may have access to all files and memories
	User Mode:
		The mode processes run in
	Kernel Mode:
		The mode the OS runs in
	Trap:
		Processes use trap to swith control to the OS and get into the kernel mode
	Trap Table: 
		Used to store all syscall handler; initialized at booting system
	Return From Trap:
		Switch control back to process and get into user mode
	Switching Between Process:
		Cooperative Way:
			OS wait for syscalls from process
		Non-cooperative Way:
			OS sets up a timer when system boot, and will interrupt process by the time
		Schedualer:
			To decide wheather to switch to another process or keep running current process after the interruption

Cp13.
-------------------------------------------------------
Address Space:
	Early Systems: 
		OS is a set of routains starting from address 0 in physical memmory
	
		Process is a running program sat in physical memmory that uses the rest of the memmory,
			starting from the end of the address space 

	Multiprogramming and Time Sharing:
		Address Space(abstraction): Contains all of the memory state of the running program
		  * all memory location showed to programmers are virtual

		    Code: 
			at top of the memory, as it won't grow 
		    Heap:
			sit after code, grows downward
		    Stack:
			sit at the bottom, grows upward
		    Virtualizing Memory:
			the OS maps virturl address into physical location

		Goal of Memory Virtualization:
		    Transperancy:
			to make software doesn't realize the memory virtualization
		    Efficiency:
			make processes run efficently both in time and space
		    Protection:
			protect processes from other processes and the OS itself, to make sure the process
			  doesn't effect or be effected by other processes
Cp39.
-------------------------------------------------------
Files and Directories:
	Files: a linear array of bytes
		*each file has a low level name, usually a number
		
		Inode Number: low level name of a file
		
		File discriptor is an index, pointing to an array.
		
	Directory: contains a list of pairs
		*also has low level name
	
	Open File Table: tracks files the fd points to, current offset, and details like readability, writeability
	
	Persistent Storage(hard disk drive)
	
	File System Interface:
		Creatation:
			open("fileName", options, permission) with O_CREAT flag. (older way: creat())
		Reading and Writing:
			read(fd,buffer,bufferSize): returns buffer size
			write(fd,buffer,bufferSize): returns buffer size
				usually be called directly in highly optimized files, or printf() will be called instead
			
	Reading and Writing but not Sequencially: to read or write from a specific position by offsetting the starting point
  		
		Offset the memory:
			off_t lseek(int fildes, off_t offset, int whence);
				fildes: file descriptor
				offset: offset bytes
				whence: flags imply how to offset		

	Shared File Entries: fork() and dup()
		
		forked process will have file discriptor shared with its parent and dup will creat a file discriptor pointing
			to the same file.

	Writing Immediately with fsync(): the write() call will not write immediately, instead it will keep content to be writen
					  for a while. If sysmtem crashes before the content been written to file, the data will
					  be lost.
		fsync(int fd): forcing the system to store all dirty data immediately to a persistent file pointed by the fd.
		
	Renaming Files: eg. when using "mv foo bar", rename("foo", "bar") will be called
		
		rename(char *old, char *new) : rename old file to new file. This rename is an atomic operation, which means
			it will either rename the file succeessfully or failed with original file left, but no middle case 
			will ever happen.
	
	Getting Information About Files: stat() or fstat() syscall could be used to see the matadata
	
		metadata: information about the file the system is storing
		
		inode: the structure that each system keeps matadata in
		
	Removing Files: when using rm in command, unlink() syscall will be called
	
		unlink();
		
	Creating Directories: directory can not be written directly due to the file system
		
		mkdir(): the syscall used to create directory. An empty directory has two entities: . and ..
		
	Deleting Directories: rmdir() can only detele empty directories, it will fail when tring to delete a nonempty directory
	
	Hard Link: a human readable name linking to the inode data stracture; not allowed for directory
		
		unlink() removes the readable links, and when the link count goes to zero, the file file system can truely
			delete the file and its matadata
		
	Symbolic Link: stores the path and file name of target file as its data, and its size depends on the path and name
			length of the target data
	
	Permission Bits and Control List;
	
	Making and Mounting File System:
		mkfs : makes a file system
		mount : mount a file system to current file tree
		
Cp40.
-------------------------------------------------------
File System Implementation (using vsfs(Very Simple File System) as example)

	Two Ways To Think A File System:
		
		Data Structure: How the data is structured on the disc
		
		Access Method: How does the file system maps the calls onto the structure
		
	The Overall Orgnazition:
		
		Inode: Structure used to store a file's metadata
		
		Inode Table: An array of on-disk inodes
		
		Data Region: A region of a file system used to store user data
		
		Bitmap: A structure that indicates if the corresponding object/block is free(0) or in-use(1) 
			data bitmap: used for data region 
			inode bitmap: used for inode region
		
		Super Block: A block that contains the information about the file system 
			     (like the how many inodes and data blocks are in the file system)
	
	
	
	
	
	
	
