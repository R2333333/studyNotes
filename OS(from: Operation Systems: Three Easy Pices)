
Cp4.	
-------------------------------------------------------		
Processes(abstract): (virtualizing the cpu, makes illusion for each process that they own the entire CPU)
	Time Sharing:
		Allow processes to share the same resource one while by one while	
	Space Sharing:
		Divide resouce in to parts for sharing purpose
		
	DataStructures:
	
Cp5.
-------------------------------------------------------
ProcessAPI:
	System Calls:
    	<unistd.h>:
        	int execl(const char* path, const char* arg, const char* arg,.......)
        	int execv(const char *path, char *const argv[])
        	int execle(const char *path, const char *arg,..., char * const envp[])
        	int execvpe(const char *file, char *const argv[],char *const envp[])
        	fork()
        	wait()

    	<fcntl.h>:
        	open(const char* path, int Oflag, ...)
	
	CREATE: turn programs into processes, by loading codes into memory and address, 
		allocate memory for stack and heap, initializations like setting up file discriptors for std I/O.
		
		Lazily: load only when needed
			Paging, Swapping.
			
		Eagerly: load all before running
		
	
	DESTROY, WAIT, MISCELLANCE CONTROL 
	
	STATUS: Running, Ready, Blocked, Initial, Final(Zombie state: process finished but not cleaned up)
	
	
	Schedualer
	
Cp6.
-------------------------------------------------------
Limited Direct Execution: Makes processes run efficiently and safely
	Direct Execution:
		Runs processes directly. Processes may have access to all files and memories
	User Mode:
		The mode processes run in
	Kernel Mode:
		The mode the OS runs in
	Trap:
		Processes use trap to swith control to the OS and get into the kernel mode
	Trap Table: 
		Used to store all syscall handler; initialized at booting system
	Return From Trap:
		Switch control back to process and get into user mode
	Switching Between Process:
		Cooperative Way:
			OS wait for syscalls from process
		Non-cooperative Way:
			OS sets up a timer when system boot, and will interrupt process by the time
		Schedualer:
			To decide wheather to switch to another process or keep running current process after the interruption

Cp13.
-------------------------------------------------------
Address Space:
	Early Systems: 
		OS is a set of routains starting from address 0 in physical memmory
	
		Process is a running program sat in physical memmory that uses the rest of the memmory,
			starting from the end of the address space 

	Multiprogramming and Time Sharing:
		Address Space(abstraction): Contains all of the memory state of the running program
		  * all memory location showed to programmers are virtual

		    Code: 
			at top of the memory, as it won't grow 
		    Heap:
			sit after code, grows downward
		    Stack:
			sit at the bottom, grows upward
		    Virtualizing Memory:
			the OS maps virturl address into physical location

		Goal of Memory Virtualization:
		    Transperancy:
			to make software doesn't realize the memory virtualization
		    Efficiency:
			make processes run efficently both in time and space
		    Protection:
			protect processes from other processes and the OS itself, to make sure the process
			  doesn't effect or be effected by other processes
Cp39.
-------------------------------------------------------
Files and Directories:
	Files: a linear array of bytes
		*each file has a low level name, usually a number
		
		Inode Number: low level name of a file
		
		File discriptor is an index, pointing to an array.
		
	Directory: contains a list of pairs
		*also has low level name
	
	Open File Table: tracks files the fd points to, current offset, and details like readability, writeability
	
	Persistent Storage(hard disk drive)
	
	File System Interface:
		Creatation:
			open("fileName", options, permission) with O_CREAT flag. (older way: creat())
		Reading and Writing:
			read(fd,buffer,bufferSize): returns buffer size
			write(fd,buffer,bufferSize): returns buffer size
				usually be called directly in highly optimized files, or printf() will be called instead
			
	Reading and Writing but not Sequencially: to read or write from a specific position by offsetting the starting point
  		
		Offset the memory:
			off_t lseek(int fildes, off_t offset, int whence);
				fildes: file descriptor
				offset: offset bytes
				whence: flags imply how to offset		

	Shared File Entries: fork() and dup()
		
		forked process will have file discriptor shared with its parent and dup will creat a file discriptor pointing
			to the same file.

	Writing Immediately with fsync(): the write() call will not write immediately, instead it will keep content to be writen
					  for a while. If sysmtem crashes before the content been written to file, the data will
					  be lost.
		fsync(int fd): forcing the system to store all dirty data immediately to a persistent file pointed by the fd.
		
	Renaming Files: eg. when using "mv foo bar", rename("foo", "bar") will be called
		
		rename(char *old, char *new) : rename old file to new file. This rename is an atomic operation, which means
			it will either rename the file succeessfully or failed with original file left, but no middle case 
			will ever happen.
	
	Getting Information About Files: stat() or fstat() syscall could be used to see the matadata
	
		metadata: information about the file the system is storing
		
		inode: the structure that each system keeps matadata in
		
	Removing Files: when using rm in command, unlink() syscall will be called
	
		unlink();
		
	Creating Directories: directory can not be written directly due to the file system
		
		mkdir(): the syscall used to create directory. An empty directory has two entities: . and ..
		
	Deleting Directories: rmdir() can only detele empty directories, it will fail when tring to delete a nonempty directory
	
	Hard Link: a human readable name linking to the inode data stracture; not allowed for directory
		
		unlink() removes the readable links, and when the link count goes to zero, the file file system can truely
			delete the file and its matadata
		
	Symbolic Link: stores the path and file name of target file as its data, and its size depends on the path and name
			length of the target data
	
	Permission Bits and Control List;
	
	Making and Mounting File System:
		mkfs : makes a file system
		mount : mount a file system to current file tree
		
Cp40.
-------------------------------------------------------
File System Implementation (using vsfs(Very Simple File System) as example)

	Two Ways To Think A File System:
		
		Data Structure: How the data is structured on the disc
		
		Access Method: How does the file system maps the calls onto the structure
		
	The Overall Organizition:
		
		Inode: Structure used to store a file's metadata
		
		Inode Table: An array of on-disk inodes
		
		Data Region: A region of a file system used to store user data
		
		Bitmap: A structure that indicates if the corresponding object/block is free(0) or in-use(1) 
			data bitmap: used for data region 
			inode bitmap: used for inode region
		
		Super Block: A block that contains the information about the file system 
			     (like the how many inodes and data blocks are in the file system)
	
	File Organization: The Inode
		
		Inode: the short for index node
			including: file type, size, number of blocks, protection information, time information
	
		The Multi-Level Index: 
			Inodes need to point to the blocks. In case the block is too larger that needs
			too many pointers, which many excess the limits of the pointers. Using the pointer of an inode
			points to another block that contains mutiple pointers is called multi-level index, and the pointers
			are call indirect pointers.
	
	Directory Organizationï¼šA directory is a list of pairs(entry names, inode numbers).
		
		Record Length: total bytes of name pluse left over space(since every delinck will left an empty space)
		
	Free Space Management: Keeps tracking free space (by bitmap in the vsfs, or a free list in some OS)
	
	Access Paths: ("/foo/bar" for example)
		
		Reading From DisK:
			open("/foo/bar", O_RDONLY):
				1. Read root inode
				2. Traverse pointers inside the inode to find entry for foo (foo's inode number found this step)
				3. Traverse directory data of foo to find bar (bar's inode number found)
				4. Read bar's inode into memory
				5. Final permission check, allocate a file discriptor, return fd to user
				
			read():
				1. Consulting inode to find the first block to read (unlees used lseek)
				2. Update inode (atime, mtime...)
				3. Update open file table (offset)
				
		Writing To Disk:
			
			Writing without CREATE and file already opened:
				1. Read Bitmap;
				2. Write Bitmap;
				3. Read inode;
				4. Write inode;
				5. Write content;
				
			Create a file for write:
				1. Read root inode;
				2. Read root data;
				3. Read foo inode;
				4. Read foo data;
				5. Read inode bitmap;
				6. Write inode bitmap;
				7. Write foo data;
				8. Read bar inode;
				9. Write bar inode;
				10. Write foo inode;
			
	Caching an Buffering:
		
		Static Partitioning:
			Store some often used blocks in memory while boosting (may take up 10% of the memory)
		
		Dynamic Partitioning:
			Store the blocks after first usage(saves each finding or opening)
			
		Buffering:
			Store the write content in a buffer, and stores the buffer to persistent disk latter 
			(saves time by reducing write times). By schedual the operations, may skip some unnecessary steps.
			
Cp41.
-------------------------------------------------------			
Locality And Fast File System
	
	The Problem: Poor Performance
	
		Old Unix File Systems
			
			Has three part, Super Block, Inodes, and Data Block
			
			Store data at next avilibal blocks
				The data may get spreaded into random block 
				(eg. amoung data a, b, c, d, remove small data b and d, then place large file e,
				 it becomes a, e(partial), c, e(partial));
	
	FFS: Disk Awareness Is The Solution(Fast File System)
		Has same API(open(), read(), write(), close()), but different implementation
		
	Oganizing Structure: The Cylinder Group
		The FFS divides the Disk into a Number of Cylinder Groups, and copies super blockes into each groups
		If one super block crupts, it can still mount the device using other replica
		
		Cyclinder: Tracks on different surface with same radius from the center of the disk
		
		Track: A curcular path on a disk surface
		
		----------------------------------------------
		|S|ib db|	Data			     |
		----------------------------------------------
		
	Policies: How to Allocate Directories and Files
		Keeps related directory and files close and irrelated far away.
		
		For Directory: Find groups with high number of free inodes and lownumber of directory allocated
		
		For Files:	
			1. Place in same groups with their inodes
			2. Place in same groups with their directory
		
		For example: the directory /, a, b, files /a/c, /a/d, /a/e, /b/f
		FFS:
		group 	inodes		data
		  0	 /		/---------
		  1	 acde		aabbccddee
		  2	 bf		bffff-----
		  ...
		  
		 Regular:
		 groups	 inodes		data
		   0	  /		/----------
		   1	  a		aa---------
		   2	  b		bb---------
		   3	  c		cc---------
		   4	  d		dd---------
		   5	  e		ee---------
		   6	  f		ffff-------
		   ...
		   
	File Locality:
		How Far away two files are. (eg. for /a/b, /a/c, /a/b/d, /a/c/e, b and c have difference 1, d and e have 2)
		
	The Large-File Exception:
		   
		  
		  
		  
	
		
		
		
	
		
		
