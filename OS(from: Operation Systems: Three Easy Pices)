ProcessAPI:
	System Calls:
    	<unistd.h>:
        	int execl(const char* path, const char* arg, const char* arg,.......)
        	int execv(const char *path, char *const argv[])
        	int execle(const char *path, const char *arg,..., char * const envp[])
        	int execvpe(const char *file, char *const argv[],char *const envp[])
        	fork()
        	wait()

    	<fcntl.h>:
        	open(const char* path, int Oflag, ...)
	
	CREATE: turn programs into processes, by loading codes into memory and address, 
		allocate memory for stack and heap, initializations like setting up file discriptors for std I/O.
		
		Lazily: load only when needed
			Paging, Swapping.
			
		Eagerly: load all before running
		
	
	DESTROY, WAIT, MISCELLANCE CONTROL 
	
	STATUS: Running, Ready, Blocked, Initial, Final(Zombie state: process finished but not cleaned up)
	
	
	Schedualer
	
		
Processes(abstract): (virtualizing the cpu, makes illusion for each process that they own the entire CPU)
	Time Sharing:
		Allow processes to share the same resource one while by one while	
	Space Sharing:
		Divide resouce in to parts for sharing purpose
		
	DataStructures:
	
Address Space:
	Early Systems: 
		OS is a set of routains starting from address 0 in physical memmory
	
		Process is a running program sat in physical memmory that uses the rest of the memmory,
			starting from the end of the address space 

	Multiprogramming and Time Sharing:
		Address Space(abstraction): Contains all of the memory state of the running program
		  * all memory location showed to programmers are virtual

		    Code: 
			at top of the memory, as it won't grow 
		    Heap:
			sit after code, grows downward
		    Stack:
			sit at the bottom, grows upward
		    Virtualizing Memory:
			the OS maps virturl address into physical location

		Goal of Memory Virtualization:
		    Transperancy:
			to make software doesn't realize the memory virtualization
		    Efficiency:
			make processes run efficently both in time and space
		    Protection:
			protect processes from other processes and the OS itself, to make sure the process
			  doesn't effect or be effected by other processes
		
Files and Directories:
	Files: a linear array of bytes
		*each file has a low level name, usually a number
		
		Inode Number: low level name of a file
		
		File discriptor is an index, pointing to an array.
		
	Directory: contains a list of pairs
		*also has low level name
	
	Open File Table: tracks files the fd points to, current offset, and details like readability, writeability
	
	Persistent Storage(hard disk drive)
	
	File System Interface:
		Creatation:
			open("fileName", options, permission) with O_CREAT flag. (older way: creat())
		Reading and Writing:
			read(fd,buffer,bufferSize): returns buffer size
			write(fd,buffer,bufferSize): returns buffer size
				usually be called directly in highly optimized files, or printf() will be called instead
			
			
			
		
